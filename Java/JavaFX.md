# JavaFX Tutorial


## JavaFX

JavaFX is a set of APIs used to build GUI applications in Java.  
It is aimed to be the successor of **Swing** that was the main GUI framework in Java.  

JavaFX follows the **MVC pattern** (Model-View-Controller) for its code structure :
- the model is the application's data model
- the view is defined in the FXML file
- the controller is the code specifying what happens on GUI user events


## JavaFX Project Setup

From JDK 11, JavaFX is no longer part of the core JDK, its platform-specific JDK needs to be downloaded at https://gluonhq.com/products/javafx/  
We can download the zip, extract it in a folder, then in IntelliJ add in the "Global Libraries" all the libs inside it.

IntelliJ has a plugin installed by default for JavaFX applications.  
When we create a new project, we can select the "JavaFX" project type.

A JavaFX project uses modules, it requires a `modules-info.java` file with `requires` directives to access JavaFX modules.  
It should be automatically generated by IntelliJ at project creation :
```java
module org.example.testjavafx {
    requires javafx.controls;
    requires javafx.fxml;

    opens org.example.testjavafx to javafx.fxml;
    exports org.example.testjavafx;
}
```


## JavaFX Basics

### Main class

The `Main` class in a JavaFX project extends the `Application` abstract class and is the entry point of the GUI application.  
The `Application` class exposes several hooks in the life-cycle of the application :
- `init()` : called before the GUI application starts, can be overridden to initialize some components of the application
- `start(Stage)` : only abstract method, must be overridden to load the FXML resource and start the **stage** (application main window).
- `stop()` : called after the application is closed, can be overridden to properly finalize components of the application

A **stage** represents a window in a JavaFX application, it is the top-level container hosting a scene.  
The primary stage is the main window of the application, and other stages can be created for dialogs or secondary windows.

A **scene** represents the content inside a stage, and contains all the visual elements (nodes) of the graphical interface.  
The scene holds the scene-graph, that is a hierarchical tree of nodes.  
A scene can be associated with only one stage at a time, but we can switch scenes within a stage.  
A scene is created with a root node, which is the top-level node of the scene-graph, usually loaded from FXML.

In the `start(Stage)` method, we call the `FXMLLoader.load(fxmlResource)` method, that returns the root node of the scene-graph.   
This node represents the top-level layout node (`VBox`, `BorderPane`...) of the FXML file, used to construct the scene-graph of the scene that will be used in the primary stage.  

### Manual creation of the scene-graph

The scene-graph contains all the GUI components of the application loaded on the stage.  
It can be defined entirely by code by creating the node hierarchy.

```java
public class HelloApplication extends Application {
    @Override
    public void start(Stage stage) throws IOException {

        // top-level component of the scene-graph
        VBox root = new VBox();
        root.setAlignment(Pos.CENTER);
        root.setSpacing(20);

        // Add a label to the VBox, initially with no content
        Label label = new Label();
        label.setTextFill(Color.RED);
        label.setFont(Font.font("Times New Roman", FontWeight.BOLD, 20));
        root.getChildren().add(label);

        // Add a button to the VBox that populates the label when clicked
        Button button = new Button();
        button.setText("Click me!");
        button.setOnAction(actionEvent -> label.setText("Welcome to JavaFX !"));
        root.getChildren().add(button);

        // create a Scene with the defined scene-graph, and add it to the primary stage
        Scene scene = new Scene(root, 320, 240);
        stage.setTitle("Hello!");
        stage.setScene(scene);
        stage.show();
    }

    public static void main(String[] args) {
        launch();
    }
}
```

### Scene-graph with FXML

A preferred alternative to define the components in the scene is to use an FXML file.  
It clearly isolates the view of the application, and the behavior is delegated to a controller.

The equivalent program using FXML would use the following FXML file :
```xml
<?xml version="1.0" encoding="UTF-8"?>

<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.control.Button?>
<?import javafx.scene.text.Font?>

<VBox alignment="CENTER" spacing="20.0" xmlns:fx="http://javafx.com/fxml"
      fx:controller="org.example.testjavafx.HelloController">
  <padding>
    <Insets bottom="20.0" left="20.0" right="20.0" top="20.0"/>
  </padding>

  <Label fx:id="welcomeLabel" textFill="red">
    <font>
      <Font name="Times New Roman bold" size="20"/>
    </font>
  </Label>
  <Button text="Click me!" onAction="#onButtonClick"/>
</VBox>
```

The behavior of the VBox (in this example, the method to call on button click) is defined in a controller class :
```java
public class HelloController {
    @FXML
    private Label welcomeLabel;

    @FXML
    protected void onButtonClick() {
        welcomeLabel.setText("Welcome to JavaFX !");
    }
}
```

The `Main` class no longer defines the GUI controls, it only loads the scene-graph from the FXML file :
```java
public class HelloApplication extends Application {
    @Override
    public void start(Stage stage) throws IOException {
    
        // load the scene-graph from the FXML file
        FXMLLoader fxmlLoader = new FXMLLoader(HelloApplication.class.getResource("hello-view.fxml"));
        Parent root = fxmlLoader.load();

        // create a Scene with the defined scene-graph, and add it to the primary stage
        Scene scene = new Scene(root, 320, 240);
        stage.setTitle("Hello!");
        stage.setScene(scene);
        stage.show();
    }

    public static void main(String[] args) {
        launch();
    }
}
```


## JavaFX Layouts

Layouts are container components that define the positioning of the graphical nodes in the scene.  
JavaFX includes multiple built-in layouts that can be used to organize the view :

- `HBox` : arrange nodes in a horizontal row
- `VBox` : arrange nodes in a single vertical column
- `BorderPane` : divide the screen into 5 areas : top / bottom / left / right / center
- `GridPane` : arrange nodes in a grid
- `StackPane` : stack nodes above each other (for example a text label above an image)

### GridPane

The `GridPane` layout arranges the nodes in a grid of cells.  
Each node inside the GridPane indicates its cell position with `GridPane.rowIndex` and `GridPane.columnIndex`.  

By default, the GridPane fits the rows and columns size to the biggest content among cells in that row or column.  
We can specify a size, either with a fixed size or a percentage of the total space, with column constraints.

```xml
<GridPane alignment="CENTER" xmlns:fx="http://javafx.com/fxml"
          fx:controller="org.sample.testjavafx.HelloController"
          hgap="10" vgap="10" gridLinesVisible="true">
  <columnConstraints>
    <ColumnConstraints percentWidth="20.0"/>
    <ColumnConstraints percentWidth="80.0"/>
  </columnConstraints>
  <Label text="0-0" GridPane.rowIndex="0" GridPane.columnIndex="0"/>
  <Label text="0-1" GridPane.rowIndex="0" GridPane.columnIndex="1"/>
  <Label text="1-0" GridPane.rowIndex="1" GridPane.columnIndex="0"/>
  <Label text="1-1" GridPane.rowIndex="1" GridPane.columnIndex="1" GridPane.rowSpan="2"/>
  <Label text="2-0" GridPane.rowIndex="2" GridPane.columnIndex="0"/>
</GridPane>
```

### HBox / VBox / FlowPane / TilePane

The `HBox` layout arranges nodes in a single horizontal row (for example OK and Cancel buttons).  
The `VBox` layout is similar, but arranges nodes vertically (for a vertical menu for example).  
These 2 layouts are rarely used as top-level layout, usually they are used as nodes of another layout.

```xml
<HBox alignment="bottom_right" xmlns:fx="http://javafx.com/fxml"
      fx:controller="org.example.testjavafx.HelloController"
      spacing="5"
      style="-fx-border-color: red; -fx-border-width: 1; -fx-border-style: solid">
  <padding>
    <Insets bottom="10" right="10" />
  </padding>
  <Button text="OK" prefWidth="70" />
  <Button text="Cancel" prefWidth="70" />
  <Button text="Apply" prefWidth="70" />
</HBox>
```

A `FlowPane` layout is similar to the `HBox` and `VBox` layouts, it aligns its children either horizontally or vertically.  
The difference is that when it has no more space, it wraps the following children to the next row or column, instead of truncating them.

```xml
<FlowPane alignment="bottom_right" xmlns:fx="http://javafx.com/fxml"
          fx:controller="org.example.testjavafx.HelloController"
          orientation="HORIZONTAL"
          style="-fx-border-color: red; -fx-border-width: 1; -fx-border-style: solid">
  <padding>
    <Insets bottom="10" right="10" />
  </padding>
  <Button text="Button1" prefWidth="70" />
  <Button text="Button2" prefWidth="70" />
  <Button text="Button3" prefWidth="70" />
  <Button text="Button4" prefWidth="70" />
  <Button text="Button5" prefWidth="70" />
  <Button text="Button6" prefWidth="70" />
</FlowPane>
```

The `TilePane` layout is a variation of `FlowPane` that arranges elements in a grid when it wraps them to the next lines.  


### BorderLayout

The `BorderLayout` is the most common top-level layout in a JavaFX application.  
It arranges nodes in 5 different areas : top, bottom, left, right and center.  

Top and bottom zones expand on 100% of the width and have their content preferred height.  
Left and right zones expand on 100% of the remaining height and have their content preferred width.  
The center zone expands on the remaining space.  
Every zone is optional, if a zone has no component it does not use any space.

```xml
<BorderPane xmlns:fx="http://javafx.com/fxml"
            fx:controller="org.example.testjavafx.HelloController"
            style="-fx-border-color: red; -fx-border-width: 1; -fx-border-style: solid">
  <top>
    <Label text="Top Area" BorderPane.alignment="CENTER"
           style="-fx-border-color: blue; -fx-border-width: 1; -fx-border-style: solid"/>
  </top>
  <left>
    <Label text="Left Area" BorderPane.alignment="CENTER"
           style="-fx-border-color: blue; -fx-border-width: 1; -fx-border-style: solid"/>
  </left>
  <right>
    <Label text="Right Area" BorderPane.alignment="BOTTOM_RIGHT"
           style="-fx-border-color: blue; -fx-border-width: 1; -fx-border-style: solid"/>
  </right>
  <center>
    <Label text="Center Area" BorderPane.alignment="CENTER_LEFT"
           style="-fx-border-color: blue; -fx-border-width: 1; -fx-border-style: solid"/>
  </center>
  <bottom>
    <HBox spacing="5" alignment="top_right">
      <padding>
        <Insets bottom="10" right="10" />
      </padding>
      <Button text="OK" prefWidth="70" />
      <Button text="Cancel" prefWidth="70" />
      <Button text="Apply" prefWidth="70" />
    </HBox>
  </bottom>
</BorderPane>
```

### StackPane

The `StackPane` layout displays its children on top of each other on a stack (so the last one hides the previous ones).  
It can be used to add annotations on an image for example.

```xml
<StackPane  xmlns:fx="http://javafx.com/fxml"
           fx:controller="org.sample.testjavafx.HelloController" >
  <Button text="Button 1" prefWidth="70" />
  <Label text="This is the label" style="-fx-background-color: pink"/>
</StackPane>
```


## JavaFX Controls

The `Control` class is the common parent of all JavaFX nodes that the user can interact with.  
This includes buttons, checkboxes, text inputs ...  
Oracle maintains a good javadoc documentation for all the JavaFX components.  

The controls belong to a complex hierarchy of Java classes, for example :
`Object` > `Node` > `Region` > `Control` > `Labeled` > `Button`

Controls inherit methods and properties from all their parent classes.  
For example, the `Button` class inherits its `text` property from the `Labeled` class.

### Button / ToggleButton

```xml
<!-- simple button -->
<Button text="Button 1" prefWidth="70" />

<!-- button with an icon before the text (that must be in the classpath) -->
<!-- the image needs to be in the images folder of the module resources for example -->
<Button text="Like" >
  <graphic>
    <ImageView>
      <Image url="@images/heart.gif"/>
    </ImageView>
  </graphic>
</Button>
```
The `ToggleButton` is a button that supports 2 states : pressed and not pressed.

```xml
<ToggleButton fx:id="showExpiredToggleButton" text="Also show expired items" />
```


### Label / Hyperlink

```xml
<!-- simple label -->
<Label text="This is the label" 
       textFill="blue"
       style="-fx-background-color: pink"/>

<!-- label with a custom icon, just like buttons -->
<Label text="Info">
  <graphic>
    <ImageView>
      <Image url="@images/heart-art.gif"/>
    </ImageView>
  </graphic>
</Label>

<!-- label with a custom font -->
<Label text="Info">
  <font>
    <Font name="Arial italic" size="20" />
  </font>
</Label>
```

The `Hyperlink` control is a variation of the `Label` control that looks like an HTML link on the web.  
It is displayed in blue, underlined on hover and becomes purple when clicked.  
On click it does nothing by default, it needs an event listener to specify what action to perform.

```xml
<Hyperlink text="www.google.com" />
```

### RadioButton

`RadioButton` nodes are designed to allow only one selected option in a group of options.  
By default, radio buttons are not part of any group, so they can be selected simultaneously.  
To group them, we need to define a `ToggleGroup` and set the group of each `RadioButton` node.  
The `ToggleGroup` class does not extend `Node` so it cannot be added to the FXML directly, it must be wrapped in a `fx:define` node.

```xml
<!-- ToggleGroup doesn't extend Node so it needs to be wrapped in a fx:define node -->
<fx:define>
  <ToggleGroup fx:id="group1" />
</fx:define>

<!-- group of radio buttons -->
<RadioButton text="A" toggleGroup="$group1" />
<RadioButton text="B" toggleGroup="$group1" />
<RadioButton text="C" toggleGroup="$group1" selected="true" />
```

### CheckBox

```xml
<CheckBox text="Subscribe" />
```

### TextField / PasswordField

```xml
<TextField />         <!-- input field for the user to type  -->
<PasswordField />     <!-- same but hiding the typed characters and preventing copy  -->
```

### ComboBox / CheckBox

A `ComboBox` node is a dropdown of options where only one can be selected.  
The `CheckBox` is functionally identical, but has a different visual aspect with a check icon in front of the selected option.

```xml
<ComboBox>
  <items>
    <FXCollections fx:factory="observableArrayList">
      <String fx:value="Option 1" />
      <String fx:value="Option 2" />
      <String fx:value="Option 3" />
    </FXCollections>
  </items>
</ComboBox>
```

### Slider / Spinner

The `Slider` and `Spinner` controls allow to select a numeric value within a range of values.  
The `Slider` is displayed as a cursor sliding on an horizontal line representing the allowed range of values.  
The `Spinner` is displayed as a text field containing the numeric value, and arrow buttons to increment or decrement it.

```xml
<!-- select a number in a range with a visual handle sliding on an horizontal line -->
<Slider min="0" max="100"
        showTickLabels="true"
        showTickMarks="true"
        minorTickCount="4"
        snapToTicks="true"/>

<!-- select a number in a range from a text field with arrow buttons -->
<Spinner min="0" max="100" editable="true" initialValue="50"/>
```

### ColorPicker / DatePicker

The `ColorPicker` is a control that lets us select a color, either among predefined colors or a custom RGB code.  
The `DatePicker` is a control that lets us select a day from a calendar popup.

```xml
<ColorPicker />
<DatePicker />
```

### Accordion

The `Accordion` control contains multiple closable panels of type `TitledPanel`.  
Only one panel can be open at a time.  
This is useful for menus with sub-menus for example, to ensure only one top-level menu is open at any time.

```xml
<Accordion expandedPane="$tp2">
  <panes>
    <TitledPane fx:id="tp1" text="Section 1">
      <Label text="Content 1" />
    </TitledPane>
    <TitledPane fx:id="tp2" text="Section 2">
      <Label text="Content 2" />
    </TitledPane>
    <TitledPane fx:id="tp3" text="Section 3">
      <Label text="Content 3" />
    </TitledPane>
  </panes>
</Accordion>
```

### MenuBar / Menu / MenuItem

The `MenuBar` control creates an horizontal list of `Menu` controls.  
Each `Menu` control can be clicked to display multiple `MenuItem` controls, that can perform an action on click.

```xml
<MenuBar>
  <Menu text="File">
    <items>
      <MenuItem text="New..." onAction="#showNewItemDialog" />
      <SeparatorMenuItem />
      <MenuItem text="Exit" />
    </items>
  </Menu>
  <Menu text="Help">
    <items>
      <MenuItem text="About" />
      <MenuItem text="License" />
    </items>
  </Menu>
</MenuBar>
```
### ToolBar

The `ToolBar` control is a visual alternative to the `MenuBar` control.  
It can contain some buttons horizontally aligned.  
These buttons often contain an icon, usually without any text, only a tooltip.  
An icon can be used with the `graphic` property of the button.  
The icon must be in a folder accessible in the classpath, for example in an `images` folder at the root of the project.

```xml
<ToolBar>
  <Button onAction="#showNewItemDialog">
    <tooltip>
      <Tooltip text="New Item" />
    </tooltip>
    <graphic>
      <ImageView fitWidth="20" fitHeight="20">
        <Image url="@images/new.png" />
      </ImageView>
    </graphic>
  </Button>
</ToolBar>
```

### ListView

A `ListView` control displays a vertical list of elements inside cells.  

```xml
<ListView fx:id="todoListView" />
```
Its content can be bound to an observable list, so any change in the underlying list is reflected in the `ListView` control.  

```java
todoListView.setItems(myObservableList);
```

We can create a listener on the `ListView` so that when an item is selected, the listener method is called :
```java
todoListView.getSelectionModel().selectedItemProperty().addListener(
    (observableValue, oldVal, newVal) -> {
        if (newVal != null) {
            TodoItem item = todoListView.getSelectionModel().getSelectedItem();
            // do something with the selected item
        }
    }
);
```

By default, the `ListView` control calls `toString()` on each item in the underlying list and prints it in black in the GUI.  
Its cells alternate between white and light blue background.

This can be customized with the `setCellFactory(callback)` method, to specify the logic to style the cell based on its content.  

```java
todoListView.setCellFactory(new Callback<>() {
    @Override
    public ListCell<TodoItem> call(ListView<TodoItem> todoItemListView) {
        ListCell<TodoItem> cell = new ListCell<TodoItem>() {
            @Override
            protected void updateItem(TodoItem item, boolean empty) {
                super.updateItem(item, empty);
                if (empty) {
                    setText(null);
                } else {
                    setText(item.getDescription());
                    if (item.getDeadline().isBefore(LocalDate.now())) {
                        setTextFill(Color.RED);
                    }
                }
            }
        };
        return cell;
    }
});
```

### ContextMenu

A `ContextMenu` control is a menu that appears on right-click on an object, and its content depends on the clicked object.  
Just like a `Menu` control, the `ContextMenu` contains some `MenuItem` children.  
It can be created dynamically, and associated to a control.

```java
// create a context menu with a single MenuItem
ContextMenu contextMenu = new ContextMenu();
MenuItem clearMenuItem = new MenuItem("Clear");
clearMenuItem.setOnAction(event -> {
    // do something when the menu item is clicked
});
contextMenu.getItems().addAll(clearMenuItem);

// set this context menu to a control, so it is displayed on right-click
myLabel.setContextMenu(contextMenu);
```

### FileChooser / DirectoryChooser

The `FileChooser` and `DirectoryChooser` classes are not extending `Node` so they cannot be added to the FXML file.  
Instead, they can be open from code in a handler to a button click for example.

```java
// file chooser to select an existing file
FileChooser fileChooser = new FileChooser();
File file = fileChooser.showOpenDialog(myTopLevelPane.getScene().getWindow());

// file chooser to save a file
FileChooser fileChooser = new FileChooser();
File file = fileChooser.showSaveDialog(myTopLevelPane.getScene().getWindow());

// file chooser with custom title and file extension filters
FileChooser fileChooser = new FileChooser();
fileChooser.setTitle("Save the file");
fileChooser.getExtensionFilters().addAll(
        new FileChooser.ExtensionFilter("Text", "*.txt"),
        new FileChooser.ExtensionFilter("Images", "*.jpg", "*.png"),
        new FileChooser.ExtensionFilter("PDF", "*.pdf"));
File file = fileChooser.showOpenDialog(mainBorderPane.getScene().getWindow());
```

To allow the selection of multiple files, we can use `fileChooser.showOpenMultipleDialog(window)` instead.

### TableView

A `TableView` is a JavaFX control to display rows of data, where each row corresponds to one element.  
Each column has a header, and a cell factory deciding how it is populated for each element of the table.  

A common cell factory is `PropertyValueFactory` that uses the value of a property field of the element.  
This is the mechanism used for data binding between the data model (underlying collection) and the table view control.

```xml
<TableView fx:id="contactsTableView">
    <columns>
      <TableColumn text="First Name">
        <cellValueFactory>
          <PropertyValueFactory property="firstName" />
        </cellValueFactory>
      </TableColumn>
      <TableColumn text="Last Name">
        <cellValueFactory>
          <PropertyValueFactory property="lastName" />
        </cellValueFactory>
      </TableColumn>
    </columns>
</TableView>
```

## Events

The JavaFX application reacts to user actions on the GUI via event handlers.  
The GUI components controls fire events, and the controller can implement event handlers to execute on these events.  
The controller class implements the handler methods that the GUI thread should execute on events.  
The FXML file references these functions in the handler properties with a `#` prefix.

The controller can access the controls in the GUI by creating a variable with the name set in the `fx:id` field of the control.  
The controller must use the `@FXML` annotation on these fields so JavaFX knows it should link it with a GUI control.  
This can be used both to access values entered by the user in a `TextField` or set values in a `Label` for example.  

We can create a GUI with a name text input, a label and a button :

```xml
<VBox xmlns:fx="http://javafx.com/fxml"
      fx:controller="org.sample.testjavafx.HelloController" >

  <TextField fx:id="nameTextField" onKeyReleased="#onNameChanged" />
  <Label fx:id="helloLabel" text="Fill your name and click the button !" />
  <Button fx:id="helloButton" text="Click me" onMouseClicked="#onClickMe" />

</VBox>
```

And in the controller class, we can implement the event handlers :

```java
public class HelloController {
    @FXML
    private TextField nameTextField;

    @FXML
    private Label helloLabel;

    @FXML
    private Button helloButton;

    @FXML
    public void initialize() {
        helloButton.setDisable(true);
    }

    @FXML
    public void onClickMe(MouseEvent e) {
        helloLabel.setText(nameTextField.getText() + " clicked on " + e.getSource());
    }

    @FXML
    public void onNameChanged(KeyEvent e) {
        System.out.println(e.getText());
        helloButton.setDisable(nameTextField.getText().trim().isEmpty());
    }
}
```

We can implement the `initialize()` method that gets called before the user can interact with the GUI.


## UI Thread

JavaFX uses the UI thread to capture user actions, keep track of events that are listened to by the controller, and execute handlers.  
It is a single thread, so if a handler takes time to execute, the UI is frozen during this time.  
To avoid this bad user-experience, handlers that take time to execute should start a new `Thread` or `Runnable` task.

JavaFX controls are not thread-safe, so the controls should not be modified in a background thread.  
It is very common that a background thread needs to update the UI when the result of its calculation is available.  
In that case, We can send another Runnable to be executed by the UI thread with the `Platform.runLater(runnable)` method.

```java
@FXML
public void onClickMe(MouseEvent e) {
    // create a Runnable to start the log processing execution in a background check
    Runnable task = () -> {
        try {
            // long execution
            Thread.sleep(5000);
            // send a task to the UI thread to update its controls
            Platform.runLater(() -> {
                helloLabel.setText(nameTextField.getText() + " clicked on " + e.getSource());
                if (clearCheckBox.isSelected()) {
                    nameTextField.clear();
                }
            });
        } catch (InterruptedException ex) {
            throw new RuntimeException(ex);
        }
    };
    new Thread(task).start();
}
```


## Pop-ups 

### Alert

`Alert` controls are pre-built JavaFX pop-ups for specific tasks.  
The valid alert types are : INFORMATION, WARNING, ERROR and CONFIRMATION.  
They allow very minimal customization but are easy to display :

```java
Alert alert = new Alert(Alert.AlertType.CONFIRMATION);
alert.setTitle("Delete Todo Item");
alert.setHeaderText("Delete item: " + item.getDescription());
alert.setContentText("Are you sure ?");
alert.showAndWait().ifPresent(
    result -> {
        if (result == ButtonType.OK) {
            // delete the object from the model
        }
    }
);
```

### Dialog

A `Dialog` control also represents a popup window, but its content can be customized more that an `Alert` control.  
For example it can be used for a creation wizard and contain `Label` and `TextField` controls.  
It has its own FXML file, with the `DialogPane` top-level layout.  

```xml
<?xml version="1.0" encoding="UTF-8"?>

<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>

<DialogPane xmlns="http://javafx.com/javafx"
            xmlns:fx="http://javafx.com/fxml"
            fx:controller="org.sample.todolist.DialogController"
            headerText="Todo Item Details:">
    <content>
        <GridPane vgap="10" hgap="10">
            <Label text="Description:" GridPane.rowIndex="0" GridPane.columnIndex="0"/>
            <TextField fx:id="descriptionText" GridPane.rowIndex="0" GridPane.columnIndex="1"/>
        </GridPane>
    </content>
</DialogPane>
```

A `Dialog` object can be instantiated from the main controller.  
The content of its `DialogPane` needs to be set to the scene-graph loaded from the FXML file.

A `Dialog` can contain multiple button types, that should be added from code.  
The most common ones are OK and CANCEL.  
The `DialogPane` is displayed and returns a `ButtonType` enum when closed.  
The values from controls in its scene-graph can be accessed via the controller of the dialog pane with `fxmlLoader.getController()`.

```java
@FXML
public void showNewItemDialog() {
    // instantiate the Dialog
    Dialog<ButtonType> dialog = new Dialog<>();
    dialog.setTitle("Todo Item Creation");
    dialog.initOwner(mainBorderPane.getScene().getWindow());

    // set the loader for the dialog fxml
    FXMLLoader fxmlLoader = new FXMLLoader();
    fxmlLoader.setLocation(getClass().getResource("todoItemDialog.fxml"));
    try {
        dialog.getDialogPane().setContent(fxmlLoader.load());
    } catch (IOException e) {
        e.printStackTrace();
    }

    // set the buttons that the DialogPane should contain
    dialog.getDialogPane().getButtonTypes().add(ButtonType.OK);
    dialog.getDialogPane().getButtonTypes().add(ButtonType.CANCEL);

    // open the Dialog and wait for its result
    dialog.showAndWait().ifPresent(response -> {
       if (response == ButtonType.OK) {
           DialogController controller = fxmlLoader.getController();
           TodoItem newItem = controller.processResults();
           todoListView.getSelectionModel().select(newItem);
        }
    });
}
```


## Observable Collections

JavaFX makes use of observable collections to provide data binding.  
A `ListView` control in FXML can be bound to an observable collection with `listView.setItems(observableCollection)`.  
Any change to the observable collection will be reflected in the GUI.  

Observable collections are JavaFX wrappers above standard Java collections, with optimized events management for GUI development.  
Events are less often triggers to prevent the unnecessary trigger of GUI display too often.

JavaFX exposes the `SortedList` and `FilteredList` classes to sort or filter an underlying list.  
When the underlying list is modified, the `SortedList` or `FilteredList` automatically reflects the update.  

They can be combined to have a filtered sorted list : 
- a `FilteredList` is created with the original list as underlying observable
- a `SortedList` is created with the filtered list as underlying observable, so it only sorts after the filtering is applied

Similarly, the `SimpleStringProperty` class is an observable replacement for  the `String` class.  
It can be used in the data model when the string value change should be reflected in the GUI.  
Common examples of string property binding are in a `TextField`, or as a property of items in a `TableView` or `ListView` control.


## GUI Controls Style

JavaFX supports CSS for its GUI controls with the `style` property, with all properties having the `-fx-` prefix.  
The style can be applied to a specific control either in the FXML file or programmatically in the Java code :

```xml
<Button text="Click me" style="-fx-background-color:green;-fx-text-fill:white" />
```

```java
Button button = new Button("Click me");
button.setStyle("-fx-background-color:green;-fx-text-fill:white");
```

Just like CSS, we can specify styles to apply to all controls of a specific type by using CSS stylesheets.  
We can create a `styles.css` file and import it in the FXML file in the top-level layout with `stylesheets="@styles.css"`.

```css
.button {
    -fx-background-color: green;
    -fx-text-fill: white;
}

#button3 {
    -fx-background-color: blue;
}
```

We can change the theme in a JavaFX application, which is simply the default CSS stylesheet JavaFX uses for all its controls.  
There are 2 options shipped with JavaFX : `MODENA` (default) and `CASPIAN`.

```java
FXMLLoader fxmlLoader = new FXMLLoader(TodoListApplication.class.getResource("todolist-view.fxml"));
Parent root = fxmlLoader.load();
setUserAgentStylesheet(STYLESHEET_CASPIAN);
Scene scene = new Scene(root, 700, 600);
stage.setTitle("Hello!");
stage.setScene(scene);
stage.show();
```


## Node Transformation

The `Node` class, parent of all JavaFX controls, exposes methods to transform the node.  

```java
myLabel.setScaleX(2);
myLabel.setScaleX(2);
myLabel.rotate(90);
```

It also includes some visual effects that can be configured to customize the GUI :

```java
testLabel.setEffect(new DropShadow(10, Color.RED));
```


## Open a Web Page

We can open a web page in the system default browser with : 
```java
Desktop.getDesktop().browse(new URI("https://openjfx.io/"));
```

It is also possible to open a web page within the application using a `WebView` control in the FXML file.

```java
WebEngine engine = webView.getEngine();
engine.load("https://openjfx.io/");
```


## JavaFX Scene Builder

The Scene Builder is a GUI tool to create the layout of our JavaFX application by drag-n-dropping the controls.  
It is an alternative to writing the FXML file manually.  

It used to be part of JavaFX, now Oracle made it open-source and it is supported by the JavaFX community.  
It can be either built from source, or installed via an installer provided by Gluon : https://gluonhq.com/products/scene-builder/

Once installed, the Scene Builder can be started as stand-alone, or integrated to IntelliJ :
Settings > Languages & Frameworks > JavaFX > Path to the Scene Builder

It is convenient to have the scene builder integrated in IntelliJ, but it requires to run the program to refresh the CSS styles.  
When working with the CSS styles of the interface, it may be better to use the stand-alone scene builder application.

When that is configured, we can open an FXML file in IntelliJ and select the Scene Builder tab to open the GUI editor.  
The screen contains multiple panes :
- **top-left pane** : lists all controls, layout, menus and other components that can be included in the scene
- **bottom-left pane** : scene-graph listing all components in the scene
- **right pane** : allows detailed configuration of the selected component (position, properties, handlers...)
- **center pane** : representation of the scene with all its components


## Example JavaFX project

The `javafx-todolist` folder contains an example of a Todo-list JavaFX project.  

It loads items from a TSV file into the app and saves them when the app is closed.  
It opens a dialog popup with a custom FXML file for the creation of an item in the list.  
It opens an alert popup to confirm the deletion of an item in the list.  
It uses custom images as icons for buttons.

It is built with Gradle, and can be started by running `./gradlew.bat run` in the top-level folder.